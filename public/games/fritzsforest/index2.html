<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Haunted Gnome Trail: 1986</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
        }

        #hud {
            position: fixed;
            left: 8px;
            top: 8px;
            color: #9eff9e;
            font-family: "Courier New", monospace;
            font-size: 14px;
            text-shadow: 0 0 6px #093;
        }

        #hud .bar {
            height: 8px;
            width: 160px;
            background: #041;
            border: 1px solid #062;
            border-radius: 2px;
            margin-top: 4px;
        }

        #hud .bar>span {
            display: block;
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #1aff76, #0b9);
        }

        #hud .row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        #help {
            position: fixed;
            right: 8px;
            top: 8px;
            color: #79f;
            font-family: "Courier New", monospace;
            font-size: 12px;
            opacity: .8;
        }

        #title {
            position: fixed;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-family: "Press Start 2P", "Courier New", monospace;
            font-size: 20px;
            letter-spacing: 2px;
            color: #6fef6f;
            text-shadow: 0 0 6px #4f0, 0 0 12px #0f0, 2px 2px 0 #320032;
            animation: flicker 2.5s infinite;
            pointer-events: none;
        }

        @keyframes flicker {

            0%,
            19%,
            21%,
            23%,
            25%,
            54%,
            56%,
            100% {
                opacity: 1;
            }

            20%,
            24%,
            55% {
                opacity: 0.6;
            }
        }

        #splashScreen {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, #000 0%, #010 80%, #000 100%);
            color: #9eff9e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-family: "Press Start 2P", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.6em;
            letter-spacing: 1px;
            z-index: 999;
            text-shadow: 0 0 8px #0f0, 0 0 16px #030;
        }

        #splashScreen h1 {
            font-size: 20px;
            margin-bottom: 1.5em;
            color: #6fef6f;
            text-shadow: 0 0 6px #4f0, 0 0 12px #0f0, 2px 2px 0 #320032;
        }

        #splashContent {
            max-width: 600px;
            padding: 20px;
        }

        .blink {
            animation: blinkAnim 1.2s infinite;
        }

        @keyframes blinkAnim {

            0%,
            50%,
            100% {
                opacity: 1;
            }

            25%,
            75% {
                opacity: 0.4;
            }
        }

        .fadeOut {
            animation: fadeOut 1.2s forwards;
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        #joystick {
            position: fixed;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(100, 255, 100, 0.3);
            background: rgba(0, 40, 0, 0.3);
            touch-action: none;
        }

        #stickDot {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: 0.05s;
        }


        #fireBtn {
            position: fixed;
            bottom: 60px;
            right: 50px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 64, 64, 0.6);
            color: white;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            user-select: none;
        }

        #fireBtn:active {
            background: rgba(255, 0, 0, 0.8);
        }

        canvas {
            width: 100vw;
            height: 100vh;
            touch-action: none;
            /* stops scrolling or pinch zoom on mobile */
        }
    </style>
</head>

<body>
    <div id="splashScreen">
        <div id="splashContent">
            <h1>FRITZ‚ÄôS HAUNTED FOREST</h1>
            <p>
                Long ago, Fritz Wiessner owned land in an enchanted forest.<br>
                He carved trails for others to enjoy.<br><br>
                To keep them clean, he hired gnomes to help.<br>
                But one night, the gnomes turned on him ‚Äî<br>
                dragging Fritz deep into the forest.<br><br>
                The trails remain.<br>
                The gnomes haunt them still.<br><br>
                <span class="blink">Click to Enter the Forest</span>
            </p>
        </div>
    </div>
    <div id="joystick">
        <div id="stickDot"></div>
    </div>

    <div id="fireBtn">üî•</div>


    <canvas id="game"></canvas>
    <audio id="bgMusic" src="Pixel Ghosts.mp3" loop preload="auto"></audio>

    <div id="title">FRITZ‚ÄôS HAUNTED FOREST</div>

    <div id="hud">
        <div class="row">‚ù§Ô∏è HP</div>
        <div class="bar"><span id="hpFill" style="width:100%"></span></div>
        <div class="row">ü™® Rocks: <span id="rocks">‚àû</span> &nbsp; ‚≠ê Score: <span id="score">0</span></div>
        <div class="row">üèöÔ∏è House Waves: <span id="wave">0</span></div>
    </div>
    <div id="help">WASD move ¬∑ Left Mouse = throw rock toward cursor ¬∑ Stay on green trail ¬∑ World wraps</div>

    <script>
        document.body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

        (function () {
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            let W, H; const DPR = Math.min(devicePixelRatio || 1, 2);

            function fit() {
                const cssW = window.innerWidth;
                const cssH = window.innerHeight;
                W = canvas.width = Math.floor(cssW * DPR);
                H = canvas.height = Math.floor(cssH * DPR);

                ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

                // Only center if player exists
                if (typeof player !== "undefined") {
                    player.x = WORLD / 2;
                    player.y = WORLD / 2;
                }
            }



            addEventListener('resize', fit, { passive: true });

            // ===== World Settings =====
            const WORLD = 1024;
            const TILE = 12;
            const TRAIL_THICKNESS = 32;  // wider trail
            const OFFTRAIL_DPS = 2;      // slower damage per second
            const healthPacks = [];
            let levelTransition = false;



            const player = { x: WORLD / 2, y: WORLD / 3, hp: 100, maxHp: 100, speed: 2.0, facing: 0 };
            let score = 0;
            fit();

            // ===== Splash Screen =====
            const splashScreen = document.getElementById('splashScreen');

            function startGame() {
                splashScreen.classList.add('fadeOut');
                setTimeout(() => {
                    splashScreen.style.display = 'none';
                    if (bgMusic && bgMusic.paused) bgMusic.play().catch(() => { });
                    requestAnimationFrame(tick);
                }, 1000);
            }

            // Press Enter or Click / Tap anywhere
            document.addEventListener('keydown', e => {
                if (e.key === 'Enter' && splashScreen.style.display !== 'none') startGame();
            });

            splashScreen.addEventListener('click', () => {
                if (splashScreen.style.display !== 'none') startGame();
            });
            splashScreen.addEventListener('touchstart', () => {
                if (splashScreen.style.display !== 'none') startGame();
            });




            // ===== Background Music =====
            const bgMusic = document.getElementById("bgMusic");

            // Unlock audio on first user interaction (mobile browsers require it)
            document.addEventListener('click', () => {
                if (bgMusic.paused) {
                    bgMusic.volume = 0.4;
                    bgMusic.play().catch(() => { });
                }
            }, { once: true });

            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            function playShootSound() {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.value = 400 + Math.random() * 100;
                gain.gain.value = 0.15;
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                osc.stop(audioCtx.currentTime + 0.25);
            }

            function playPickupSound() {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 880;
                gain.gain.value = 0.2;
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                osc.stop(audioCtx.currentTime + 0.3);
            }




            // ===== Helper functions =====
            const wrap = v => (v % WORLD + WORLD) % WORLD;
            const dWrap = (a, b) => { let d = a - b; if (d > WORLD / 2) d -= WORLD; if (d < -WORLD / 2) d += WORLD; return d; };
            const torusDist2 = (ax, ay, bx, by) => { const dx = dWrap(ax, bx), dy = dWrap(ay, by); return dx * dx + dy * dy; };

            // ===== Trail Generation =====
            const trail = [];
            function genTrail() {
                trail.length = 0; // clear old trail
                let x = WORLD / 2, y = TILE * 6, dir = Math.PI / 2;
                for (let i = 0; i < 230; i++) {
                    dir += (Math.random() - 0.5) * 0.6;
                    const step = 12 + Math.random() * 10;
                    x = wrap(x + Math.cos(dir) * step);
                    y = wrap(y + Math.sin(dir) * step);
                    const sx = Math.round(x / TILE) * TILE;
                    const sy = Math.round(y / TILE) * TILE;
                    trail.push({ x: sx, y: sy });
                }
            }
            genTrail();
            window.genTrail = genTrail;


            // ===== Haunted House =====
            const haunted = {
                x: trail[trail.length - 1].x,
                y: wrap(trail[trail.length - 1].y + 40),
                size: 32,
                wave: 0,
                timer: 0,
                hp: 200,
                maxHp: 200,
                hitFlash: 0
            };


            // ===== Entities =====
            const gnomes = [];
            const rocks = [];

            function spawnGnomeNearTrail(distance) {
                const i = (Math.random() * trail.length) | 0;
                const t = trail[i];
                const ang = Math.random() * Math.PI * 2;
                const r = distance || (8 + Math.random() * 20);
                const x = wrap(t.x + Math.cos(ang) * r), y = wrap(t.y + Math.sin(ang) * r);
                gnomes.push({ x, y, bad: Math.random() < 0.7, hp: 20 });
            }

            for (let i = 0; i < 24; i++) spawnGnomeNearTrail(20);

            // ===== Input =====
            const keys = new Set();
            let moveStick = { active: false, startX: 0, startY: 0, x: 0, y: 0 };

            addEventListener('keydown', e => {
                if (['w', 'a', 's', 'd'].includes(e.key.toLowerCase())) e.preventDefault();
                keys.add(e.key.toLowerCase());
            });
            addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

            const mouse = { x: W / 2, y: H / 2 };
            addEventListener('mousemove', e => { mouse.x = e.clientX * DPR; mouse.y = e.clientY * DPR; });

            // ===== Shooting (LEFT MOUSE CLICK) =====
            let shootCD = 0;
            canvas.addEventListener('mousedown', e => {
                if (e.button === 0) tryShoot(e.clientX, e.clientY);
            });
            canvas.addEventListener('touchstart', e => {
                const t = e.touches[0];
                tryShoot(t.clientX, t.clientY);
            });

            // === Virtual Joystick for Movement ===
            // ===== FIXED ANALOG JOYSTICK (bottom-left circle) =====
            const joystick = document.getElementById('joystick');
            const stickDot = document.getElementById('stickDot');
            const joyRect = joystick.getBoundingClientRect();

            moveStick.active = false;
            moveStick.x = 0;
            moveStick.y = 0;

            joystick.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.touches[0];
                moveStick.active = true;
                handleJoystickMove(t);
            });

            joystick.addEventListener('touchmove', e => {
                e.preventDefault();
                if (!moveStick.active) return;
                const t = e.touches[0];
                handleJoystickMove(t);
            });

            joystick.addEventListener('touchend', e => {
                moveStick.active = false;
                moveStick.x = 0;
                moveStick.y = 0;
                stickDot.style.transform = 'translate(-50%, -50%)';
            });

            // ===== MOBILE BURST FIRING =====
 // ===== MOBILE AUTO-AIM BURST SHOOTING =====
canvas.addEventListener('touchstart', e => {
    const t = e.touches[0];
    // Right half starts burst
    if (t.clientX > window.innerWidth / 2 && !mobileBurstActive && burstCooldown <= 0) {
        mobileBurstActive = true;
        burstShotsRemaining = 5;
        burstCooldown = 1500;
    }
});


// === Find nearest bad gnome (auto-aim target) ===
function getAutoAimTarget() {
    let closest = null;
    let bestDist = Infinity;

    // find the nearest "bad" gnome
    for (const g of gnomes) {
        if (!g.bad) continue;
        const d2 = torusDist2(player.x, player.y, g.x, g.y);
        if (d2 < bestDist) {
            bestDist = d2;
            closest = g;
        }
    }

    // fallback to the haunted house if no bad gnomes remain
    if (!closest) closest = haunted;
    return closest;
}




            // helper
            function handleJoystickMove(t) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // distance from center
                let dx = t.clientX - centerX;
                let dy = t.clientY - centerY;
                const dist = Math.min(Math.hypot(dx, dy), rect.width / 2);
                const ang = Math.atan2(dy, dx);

                dx = Math.cos(ang) * dist;
                dy = Math.sin(ang) * dist;

                // move the dot visually
                stickDot.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                // normalize -1..1 for movement strength
                moveStick.x = dx / (rect.width / 2);
                moveStick.y = dy / (rect.height / 2);
            }


            canvas.addEventListener('touchmove', e => {
                const t = e.touches[0];
                if (!t) return;

                if (t.clientX < window.innerWidth / 2 && moveStick.active) {
                    moveStick.x = t.clientX;
                    moveStick.y = t.clientY;
                }
            });

            canvas.addEventListener('touchend', e => {
                moveStick.active = false;
            });


            document.getElementById('fireBtn').addEventListener('touchstart', e => {
                e.preventDefault();
                tryShoot(innerWidth * 0.7, innerHeight * 0.5); // shoots forward/right area
            });

            let touchAim = null;

            canvas.addEventListener("touchstart", e => {
                if (e.touches.length === 1) {
                    const t = e.touches[0];
                    const tx = t.clientX;
                    const ty = t.clientY;

                    // left half of screen = movement
                    if (tx < window.innerWidth / 2) {
                        touchAim = null; // movement only
                    } else {
                        // right half = shooting
                        tryShoot(tx, ty);
                        touchAim = { x: tx, y: ty };
                    }
                }
            });

            canvas.addEventListener("touchmove", e => {
                if (e.touches.length === 1 && touchAim) {
                    const t = e.touches[0];
                    touchAim.x = t.clientX;
                    touchAim.y = t.clientY;
                }
            });

            canvas.addEventListener("touchend", e => {
                touchAim = null;
            });


            // === Improved shooting with proper aim ===
            let mobileBurstActive = false;
            let burstShotsRemaining = 0;
            let burstCooldown = 0;


            function tryShoot(mx, my) {
                if (shootCD > 0) return;
                shootCD = 180;

                const cx = canvas.width / (2 * DPR);
                const cy = canvas.height / (2 * DPR);
                const dx = mx - cx;
                const dy = my - cy;
                const mag = Math.hypot(dx, dy) || 1;
                const sp = 6.0;

                const vx = (dx / mag) * sp;
                const vy = (dy / mag) * sp;

                playShootSound();
                rocks.push({ x: player.x, y: player.y, vx, vy, life: 1200 });
            }



            function distToTrail(px, py) {
                let best = Infinity;
                for (const n of trail) { const d2 = torusDist2(px, py, n.x, n.y); if (d2 < best) best = d2; }
                return Math.sqrt(best);
            }

            // ===== Main Loop =====
            let last = performance.now();
            function tick(now) {
                const dt = Math.min(50, now - last); last = now;
                const dtSec = dt / 1000;




                // movement
                // movement
                let mx = 0, my = 0;

                // Mobile Joystick movement
                // === Mobile Joystick movement ===
                if (moveStick.active) {
                    mx += moveStick.x;
                    my += moveStick.y;
                }

                // if (moveStick.active) {
                //     const dx = moveStick.x - moveStick.startX;
                //     const dy = moveStick.y - moveStick.startY;
                //     const dist = Math.hypot(dx, dy);
                //     if (dist > 10) {
                //         const strength = Math.min(dist / 40, 1);
                //         mx += (dx / dist) * strength;
                //         my += (dy / dist) * strength;
                //     }
                // }
                //--WASD`
                if (keys.has('w')) my -= 1;
                if (keys.has('s')) my += 1;
                if (keys.has('a')) mx -= 1;
                if (keys.has('d')) mx += 1;
                // === Player movement (keyboard + joystick combined) ===
                if (mx || my) {
                    const m = Math.hypot(mx, my);
                    mx /= m;
                    my /= m;

                    // Adjust joystick sensitivity separately from keyboard
                    const moveFactor = moveStick.active ? 0.5 : 1.0; // üëà joystick = 50% speed
                    player.x = wrap(player.x + mx * player.speed * moveFactor);
                    player.y = wrap(player.y + my * player.speed * moveFactor);
                }

                // === Player facing direction ===
                player.facing = Math.atan2((mouse.y - H / 2), (mouse.x - W / 2));

                const dTrail = distToTrail(player.x, player.y);
                if (dTrail > TRAIL_THICKNESS) {
                    player.hp = Math.max(0, player.hp - OFFTRAIL_DPS * dtSec);
                }

                // === Mobile burst shooting update ===
                // === Mobile auto-aim burst update ===
if (burstCooldown > 0) burstCooldown -= dt;

if (mobileBurstActive && burstShotsRemaining > 0) {
    if (shootCD <= 0) {
        const target = getAutoAimTarget();
        const dx = dWrap(target.x, player.x);
        const dy = dWrap(target.y, player.y);
        const mag = Math.hypot(dx, dy) || 1;

        const sp = 6.0;
        const vx = (dx / mag) * sp;
        const vy = (dy / mag) * sp;

        playShootSound();
        rocks.push({ x: player.x, y: player.y, vx, vy, life: 1200 });

        burstShotsRemaining--;
        shootCD = 120; // delay between each shot
    }
} else if (mobileBurstActive && burstShotsRemaining <= 0) {
    mobileBurstActive = false;
}



                // Gnome AI
                for (const g of gnomes) {
                    const dx = dWrap(player.x, g.x), dy = dWrap(player.y, g.y);
                    const m = Math.hypot(dx, dy) || 1;
                    if (g.bad) {
                        if (m < 180) {
                            const sp = 0.6 + Math.min(1.2, score / 600);
                            g.x = wrap(g.x + dx / m * sp);
                            g.y = wrap(g.y + dy / m * sp);
                        } else {
                            g.x = wrap(g.x + (Math.random() - 0.5) * 0.5);
                            g.y = wrap(g.y + (Math.random() - 0.5) * 0.5);
                        }
                        if (m < 14) { player.hp = Math.max(0, player.hp - 20 * dtSec); }
                    } else {
                        if (Math.random() < 0.02) { const t = trail[(Math.random() * trail.length) | 0]; g.x = t.x; g.y = t.y; }
                    }
                }



                // Haunted house waves
                haunted.timer += dt;
                if (haunted.timer > 8000) {
                    haunted.timer = 0;
                    haunted.wave++;
                    for (let i = 0; i < 3; i++) {
                        const ang = Math.random() * Math.PI * 2;
                        const r = 40 + Math.random() * 20;
                        gnomes.push({ x: wrap(haunted.x + Math.cos(ang) * r), y: wrap(haunted.y + Math.sin(ang) * r), bad: true, hp: 24 });
                    }
                }

                // === Health Pack Spawning ===
                if (Math.random() < 0.002) { // about every 20 sec
                    const t = trail[(Math.random() * trail.length) | 0];
                    healthPacks.push({ x: t.x, y: t.y, life: 30000 }); // lasts 30 seconds
                }

                // Rocks
                shootCD = Math.max(0, shootCD - dt);
                for (let i = rocks.length - 1; i >= 0; i--) {
                    const r = rocks[i];
                    r.life -= dt;
                    r.x = wrap(r.x + r.vx);
                    r.y = wrap(r.y + r.vy);
                    if (r.life <= 0) { rocks.splice(i, 1); continue; }

                    // --- Check gnome hit ---
                    for (let j = gnomes.length - 1; j >= 0; j--) {
                        const g = gnomes[j];
                        const d2 = torusDist2(r.x, r.y, g.x, g.y);
                        if (d2 < 10 * 10) {
                            g.hp -= 18;
                            r.life = 0;
                            if (g.hp <= 0) {
                                if (g.bad) { score += 10; }
                                else { score = Math.max(0, score - 5); }
                                gnomes.splice(j, 1);
                            }
                            break;
                        }
                    }

                    // --- Check castle hit ---
                    const d2House = torusDist2(r.x, r.y, haunted.x, haunted.y);
                    if (d2House < (haunted.size * 0.8) ** 2) {
                        haunted.hp -= 10;
                        haunted.hitFlash = 5;
                        r.life = 0;
                        if (haunted.hp <= 0 && !levelTransition) {
                            haunted.hp = 0;
                            levelTransition = true;
                            nextLevel();
                        }
                    }
                }


                // === Health Pack Pickup ===
                for (let i = healthPacks.length - 1; i >= 0; i--) {
                    const p = healthPacks[i];
                    p.life -= dt;
                    const d2 = torusDist2(p.x, p.y, player.x, player.y);
                    if (d2 < 14 * 14) {
                        player.hp = Math.min(player.maxHp, player.hp + 25);
                        playPickupSound();
                        healthPacks.splice(i, 1);
                    } else if (p.life <= 0) {
                        healthPacks.splice(i, 1);
                    }
                }


                document.getElementById('hpFill').style.width = (player.hp / player.maxHp * 100).toFixed(1) + '%';
                document.getElementById('score').textContent = score | 0;
                document.getElementById('wave').textContent = haunted.wave | 0;

                render(dTrail);
                if (player.hp > 0) requestAnimationFrame(tick);
                else gameOver();
            }

            // ===== Render =====
            function render(dTrail) {
                ctx.clearRect(0, 0, innerWidth, innerHeight);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, innerWidth, innerHeight);

                ctx.globalAlpha = 0.08;
                ctx.fillStyle = '#0f0';
                for (let y = 0; y < innerHeight; y += 2) { ctx.fillRect(0, y, innerWidth, 1); }
                ctx.globalAlpha = 1;

                const cx = W / (2 * DPR);
                const cy = H / (2 * DPR);


                ctx.fillStyle = '#003700';
                for (const n of trail) {
                    const dx = dWrap(n.x, player.x), dy = dWrap(n.y, player.y);
                    const sx = cx + dx, sy = cy + dy;
                    if (sx < -TILE || sy < -TILE || sx > innerWidth + TILE || sy > innerHeight + TILE) continue;
                    ctx.fillRect(sx, sy, TILE + 4, TILE + 4);
                }

                const dxH = dWrap(haunted.x, player.x), dyH = dWrap(haunted.y, player.y);
                const sxH = cx + dxH, syH = cy + dyH;

                // === Gnome Castle ===
                if (haunted.hitFlash > 0) haunted.hitFlash--;
                ctx.fillStyle = haunted.hitFlash > 0 ? '#f00' : '#310031';
                ctx.fillRect(sxH - haunted.size / 2, syH - haunted.size / 2, haunted.size, haunted.size);
                ctx.strokeStyle = '#7a3b7a';
                ctx.strokeRect(sxH - haunted.size / 2 + 0.5, syH - haunted.size / 2 + 0.5, haunted.size - 1, haunted.size - 1);

                // Castle health bar (visible if not full)
                if (haunted.hp < haunted.maxHp) {
                    ctx.fillStyle = '#400';
                    ctx.fillRect(sxH - 20, syH - haunted.size / 2 - 8, 40, 4);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(sxH - 20, syH - haunted.size / 2 - 8, (haunted.hp / haunted.maxHp) * 40, 4);
                }


                for (const g of gnomes) {
                    const dx = dWrap(g.x, player.x), dy = dWrap(g.y, player.y);
                    const sx = cx + dx, sy = cy + dy;
                    if (sx < -8 || sy < -8 || sx > innerWidth + 8 || sy > innerHeight + 8) continue;
                    ctx.fillStyle = g.bad ? '#f44' : '#4f4';
                    ctx.fillRect(sx - 3, sy - 3, 6, 6);
                }

                ctx.fillStyle = '#ccc';
                for (const r of rocks) {
                    const dx = dWrap(r.x, player.x), dy = dWrap(r.y, player.y);
                    const sx = cx + dx, sy = cy + dy;
                    ctx.fillRect(sx - 2, sy - 2, 4, 4);
                }

                // === Health Packs ===
                for (const p of healthPacks) {
                    const dx = dWrap(p.x, player.x), dy = dWrap(p.y, player.y);
                    const sx = cx + dx, sy = cy + dy;
                    const pulse = 0.5 + 0.5 * Math.sin(performance.now() / 200);
                    ctx.fillStyle = `rgba(100,200,255,${0.7 + pulse * 0.3})`;
                    ctx.fillRect(sx - 4, sy - 4, 8, 8);
                }

                if (moveStick.active) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(moveStick.startX, moveStick.startY, 30, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(moveStick.startX, moveStick.startY);
                    ctx.lineTo(moveStick.x, moveStick.y);
                    ctx.stroke();
                    ctx.restore();
                }



                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(player.facing);
                ctx.fillStyle = '#7cf';
                ctx.fillRect(-4, -4, 8, 8);
                ctx.fillStyle = '#dff';
                ctx.fillRect(3, -2, 3, 4);
                ctx.restore();

                if (dTrail > TRAIL_THICKNESS) {
                    ctx.strokeStyle = 'rgba(255,64,64,0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 16 + ((performance.now() / 120) % 3), 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            function nextLevel() {
                console.log('Level Cleared!');
                haunted.timer = 0;
                haunted.wave = 0;
                gnomes.length = 0;
                healthPacks.length = 0; // clear leftover packs

                // visual message
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, innerWidth, innerHeight);
                ctx.fillStyle = '#6fef6f';
                ctx.font = '22px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('CASTLE CLEANSED!', innerWidth / 2, innerHeight / 2 - 20);
                ctx.font = '14px "Press Start 2P", monospace';
                ctx.fillText('The forest grows quieter...', innerWidth / 2, innerHeight / 2 + 20);

                playPickupSound(); // satisfying ping

                setTimeout(() => {
                    // Generate new trail for next level
                    genTrail();
                    const last = trail[trail.length - 1];
                    haunted.x = last.x;
                    haunted.y = last.y;
                    haunted.hp = haunted.maxHp;
                    player.x = trail[0].x;
                    player.y = trail[0].y;
                    player.hp = player.maxHp;
                    gnomes.length = 0;
                    for (let i = 0; i < 24; i++) spawnGnomeNearTrail(20);
                    score += 100;
                    levelTransition = false; // ‚úÖ allow next transition again
                }, 2500);

            }



            function gameOver() {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, innerWidth, innerHeight);
                ctx.fillStyle = '#fff';
                ctx.font = '24px Courier New, monospace';
                ctx.fillText('GAME OVER', innerWidth / 2 - 80, innerHeight / 2);
                ctx.font = '14px Courier New, monospace';
                ctx.fillText('Reload to play again', innerWidth / 2 - 86, innerHeight / 2 + 22);
            }

            function startGame() {
                splashScreen.classList.add('fadeOut');
                setTimeout(() => {
                    splashScreen.style.display = 'none';
                    if (bgMusic && bgMusic.paused) bgMusic.play().catch(() => { });
                    requestAnimationFrame(tick); // üëà game starts here
                }, 1000);
            }
        })();
    </script>
</body>

</html>